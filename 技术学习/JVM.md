[toc]

# JVM

## JDK/JRE/JVM的关系 

1. JDK/JRE/JVM的关系 

   1. JDK开发工具包
      (java development kit)支持开发和运行java程序。
      JDK包含JRE以及各种Java开发工具（如编译器javac、调试器jdb等）
   2. JRE运行环境
      (Java runtime environment)能够运行已编译的Java程序。
      JRE包含JVM以及运行时所需调用的基础类库（如java.lang包、java.unit包等）
   3. JVM虚拟机
      (java virtual machine)运行Java程序的工作环境
      Java 程序在虚拟机上运行而不是直接在操作系统上运行，从软件层面屏蔽了底层硬件指令的细节。虚拟机会根据操作系统自动将字节码文件转化成相应的机器码，使 Java 字节码文件能够在多种平台上不加修改地运行。

   <!--HotSpot 虚拟机 是 SunJDK 和 OpenJDK 中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机。-->

## Java运行原理

1. Java运行原理

   1. 基本概念

      1. 解释和编译
         - 解释：源文件经过编译器编译成为脚本文件，由解释器逐行解释并执行。灵活性更好。
         - 编译：源文件经过编译成为可执行文件，由计算机直接去执行。性能更好。
      2. 静态编译和动态编译
         - 静态编译：编译时确定类型，绑定对象。性能更好。
         - 动态编译：运行时确定类型，绑定对象。能更好地支持多态，灵活性强。

   2. Java运行原理
      <!--Java是编译和解释并行的语言，采取动态编译，支持反射机制。-->

      1. 源文件(.java)经过编译器编译成为字节码文件(.class)，通过类加载器搬运到JVM中逐行解释并执行。
      2. 即时编译器(JIT)在编译时会识别反复执行的热点代码(超过10000次)并保存机器码，复用时可以直接由JVM执行。

      - 优势：以虚拟机作为中介，字节码文件可以在所有操作平台上通用。即一次编译、到处运行。
      - 劣势：但这也导致了Java语言性能不如C/C++等编译语言。

## 类加载

1. 类加载
   在Java程序里如果使用某个尚未加载到内存中的类，JVM会通过加载、链接、初始化3个步骤来对该类进行初始化。
   ![1](https://raw.githubusercontent.com/ZJL2019/picGo/main/img/202201271419069.png)
   <!--创建类的实例，访问类的静态变量，或者调用类的静态方法都会导致类的初始化。但要注意对于final常量，如果在编译时就可以确定该变量的值，编译器会在编译时直接把这个变量替换成它的值，因此即时程序使用该静态变量，也不会导致该类的初始化。-->

2. 加载
   **类的加载由类加载完成。类加载器会读取类的字节码文件，并为之创建一个java.lang.Class对象。**
   类加载器使用双亲委派模型，类加载器具备一种带有优先级的层次关系：

   - 根类加载器：负责加载Java的核心类，原生代码实现，并不继承自java.lang.ClassLoader类。
   - 扩展类加载器：负责加载JRE扩展目录中的类。由Java语言实现，没有父类加载器。
   - 系统类加载器：负责加载CLASSPATH路径中的类。由Java语言实现，父类加载器为扩展类加载器。
   - 用户类加载器：开发者通过继承ClassLoader基类来创建的类加载器。由Java语言实现，默认父类加载器为系统类加载器。

   任何类加载器在接到加载类的请求时，都会将加载任务委托给父类加载器，最终委派给处于模型最顶端的根类加载器进行加载。只有父类加载器无法完成此加载任务时，才自己去加载。如果均无法载入类，则抛出ClassNotFountException异常。

   1. 通过这种层级关系可以避免类的重复加载。
   2. 其次可以防止核心API库被随意篡改，用户即时编写了java.lang.Object的同名类，也永远无法被加载运行。

   【在双亲委派模型中，由父加载类加载的类，下层加载器是不能加载的。用户在classpath路径下自定义的java.*包内的类会抛出异常：SecurityException：Prohibited package name】

3. 链接
   **当类被加载并生成Class对象后，链接阶段负责把类的二进制数据合并到JRE中。**

   - 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
   - 准备：类准备阶段负责为类的静态变量分配内存，并赋予类的默认值。
   - 解析：将类的二进制数据中的符号引用替换成直接引用，指向具体的内存空间。

   <!--Java是相对C++语言是安全的语言，验证过程用于确保Class文件的字节流符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。-->

4. 初始化
   **为类的静态变量赋予程序设定的**

## 内存空间

Java程序中得分内存分配和回收都由JVM管理，不支持程序员直接对内存地址进行操作。不容易出现内存泄漏和内存溢出问题。

1. 内存空间
   进程是分配资源的基本单位。除方法区外，所有数据均存放在给进程分配的内存块中。
   Java程序的内存空间主要分为以下几个区域：
   ![3](https://raw.githubusercontent.com/ZJL2019/picGo/main/img/202201301112506.png)
   
2. 方法区
   (Method Area)存放**Java程序二进制代码，即类的信息**
   在虚拟机启动时直接存入系统内存中，大小只受系统内存的限制。

3. 堆区
   (Heap)存放进程创建的**对象实例和数组**
   由线程共享，在虚拟机启动时为进程创建，是占用内存最大的区域。

4. 常量池
   存放**final常量、static变量和方法，以及String和部分包装类型的对象（一经赋值不再改变）**
   <!--JDK1.7后JVM将常量池从方法区中移出，改为在堆中开辟空间存放。-->

5. 栈区
   (Stack)存放线程执行Java方法调用的内存数据。线程每执行一个方法都会创建一个栈帧放入栈区，在方法执行结束后弹出。栈帧中储存局部变量表、操作数栈、动态链接、方法出口信息。其中局部变量表存放**线程和方法参数、方法中定义的基础类型变量和对象引用。**
   由线程私有。生命周期随着线程的创建而创建，随着线程的结束而死亡。
   <!--栈区分为虚拟机栈（执行java方法）和本地方法栈（执行native方法，底层用C实现），但在HotSpot虚拟机中合二为一。-->

6. 程序计数器
   用来记录线程的运行状态、管理线程的运行。

   1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
   2. 在多线程的情况下程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够继续运行。

   由线程私有。生命周期随着线程的创建而创建，随着线程的结束和死亡。

## 对象的内存分配

1. 分配空间
   Hotspot虚拟机中，对象在内存中分为3块区域：对象头、实例诗句和对齐填充。

   - 对象头负责记录对象纤细，包括对象运行数据（哈希码、GC分代年龄、锁状态标志等）和类型指针（对象所属的类）
   - 对象起止地址必须是8字节整数倍，空余部分将使用对齐填充来补全。

2. 分配过程
   在Java中创建对象，需要经过以下过程：

   1. 类加载检查

      > JVM接受到new执行，首先检查该类是否在常量池中，然后检查该类是否已被加载、解析和初始化。
      >
      > 如果没有则先加载类，类加载器会将类的字节码文件放入JVM解析。

   2. 分配内存

      > 类加载后，会从Java堆中划分一块固定大小的内存区域分配给对象

   3. 半初始化

      > 内存分配完成后，虚拟机将对象的实例数据都半初始化为默认值。此对象已经可用。

   4. 设置对象头

      > 初始化内存空间后，虚拟机要对对象进行必要的设置，把信息存放在对象头中。

   5. 初始化对象

      > 新的对象已经产生，但所有的字段都为默认值。接下来执行init方法，将对象的实例数据赋值。

   6. 建立关联

      > 将对象引用指向创建的对象。该对象可以通过引用被使用。

   <!--在创建对象的过程中可能会发生指令重排。如果尚未完全初始化就建立了关联，其他线程读取该对象可能会读取到默认值。-->

## 分配方式

1. 分配方式
   内存划分有以下两种分配方式：

   - 指针碰撞：（内存规整时）已使用内存和未使用内存用指针隔开，需要分配内存时将指针移动一定位置。
   - 空闲列表：（内存不规整时）虚拟机维护一个列表记录空闲内存块，需要分配内存时选择合适的内存块。

   Java堆是否规整，取决于垃圾收集算法是否整理内存。

## 常量池内存分配

1. String类
   String对象创建后一经赋值不再改变，有以下两种创建方式：

   1. 直接赋值：如果常量池没有，则在常量池新建对象。否则直接使用常量池中已有对象，**引用指向常量池。**
   2. 构造方法：如果常量池没有，则在常量池新建对象。无论如何一定会在堆区创建对象，引用指向堆区。

   ```java
   String str1 = "String";												//引用指向常量池
   String str2 = "str" + "ing";									//引用指向常量池
   
   String str3 = new String("string");						//引用指向堆区
   String str4 = str1 + str2;										//引用指向堆区
   
   System.out.println(str1 == str2);             // true
   System.out.println(str1 == str3);             // false
   ```

2. 包装类型
   JVM将部分常用的包装类型数据提起缓存在常量池中，用户创建该类对象时直接在常量池取用，而不用真正新建对象。

   - **布尔包装类Boolean**：将全部缓存数据保存在常量池中。
   - **字符包装类Character**：将ASCII字符(0-127)数据缓存保存在常量池中。如果是汉字等其他字符仍然会创建对象。
   - **整型包装类Byte/Short/Integer/Long**：将数值[-128，-127]内的数据缓存保存在常量池中。但是超出此范围仍然会去创建新的对象。
   - **浮点数类型包装类Float/Double**：没有实现常量池技术。

## 内存过载

1. 内存过载
   随着Java程序的使用，所占用和分配的内存将会越来越大。如果JVM已无法分配足够的内存，将会抛出OutOfMemoryError导致程序崩溃。
   同时为了更合理地使用内存，Java会由虚拟机对堆区内存空间自动进行垃圾回收。

## 垃圾回收

1. 垃圾回收
   Java的自动内存管理主要是针对对象内存的回收和对象内存的分配，堆区是垃圾收集器管理的主要区域。
   开发者使用System.gc()方法可以提醒JVM进行垃圾回收，但不能强制。
2. 分区回收
   现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代。进一步划分的目的是更好地回收内存，或者更快地分配内存。
   - 新生代GC(Minor GC)：新生代垃圾回收非常频繁，回收速度也比较快。
   - 老年代GC(Major GC)：老年代垃圾回收次数较少，回收速度也明显更慢。![未命名](https://raw.githubusercontent.com/ZJL2019/picGo/main/img/202202081442159.png)
3. 初次分配对象
   新生代分为eden区和survive区，其中eden区占用内存空间更大。
   大多数情况下，对象在新生代eden区分配，当eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
4. 长期存活对象
   虚拟机给每个对象设置一个年龄计数器。如果对象经过一次Minor GC后仍然能够存活，将从eden移动到survive空间中。对象每熬过一次Minor GC，年龄就增加1岁。当他的年龄增加到一定程度（默认为15岁），就会晋升到老年代。
   survive区分为from区和to区两块大小相等的内存空间。Minor GC执行时，将会eden区和from区中的存活对象复制到to区，清除eden区和from区内存。再把这些内存活对象从to区移动到from区。
   当老年代也没有足够空间进行分配时，虚拟机将发起一次Major GC。
5. 大对象
   需要大量连续内存空间的对象（如字符串、数组）直接进入老年代，可以避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

## 指令重排序

1. 指令概念
   指令是指示计算机执行某种操作的命令，如：数据传送指令、算术运算指令、位运算指令、程序流程控制指令、串操作指令。指令不同于我们写的代码，一行代码按照操作的逻辑可以分成多条指令。
   举个例子：int a = 1;这段代码大致可以分为两条指令：

   1. 加载常量1
   2. 将常量1赋值给变量a

2. 指令重排序
   只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做指令的重排序。
   指令重排序的意义：使指令更加符合CPU的执行特性，最大限度发挥机器的性能，提高程序的执行效率。

   1. 指令重排序分类
      指令重排序主要分为三种，在这里主要讨论JVM中的指令重排序。

      1. 编译器重排序：JVM中完成
      2. 指令级并行重排序
      3. 处理器重排序：CPU中完成

   2. 指令重排序原则
      如果程序中操作A在操作B之前，那么线程中操作A将在操作B之前执行。（只对指令内部重排序，不在指令间重排序）

      - **As-If-Serial语义**
        不管怎么进行指令排序，单线程内程序的执行结果不能被改变。
        编译器和处理器对存在依赖关系的操作都不会对其进行重排序。只有不存在依赖关系的操作有可能进行重排序。
      - **Happens-Before原则**
        保证正确同步的多线程程序的执行结果不被改变。
        对于被同步的操作，如果操作A先于操作B，那么A操作的执行结果将对B操作可见，而且A操作的执行顺序排在B操作之前。

      管理锁定原则：一个unlock操作happen-before后面（时间上的先后顺序）对同一个锁的lock操作。（如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）

3. 防止指令重排序
   volatile关键字通过”内存屏障“来防止指令被重排序。
   为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
   Java内存模型采取保守策略（见缝就插）
   在每个人volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。在每个volatile读操作的后面插入一个LoadLoad屏障。在每个人volatile读操作的后面插入一个LoadStore屏障。
   Synchronized把多线程执行环境改变为单线程执行环境，无需关心指令重排序问题（单线程执行结果不会改变）。
