## 背景：

1. 在之前学习C++的过程中，了解到linux操作系统在可以设置产生coredump文件的大小。同时在C/C++程序崩溃时会以coredump文件的形式保存堆栈信息和汇编信息，用来保存现场，以供RD更方便分析问题原因。

<!--同时我想到mac基于linux内核开发，应该也会有coredump文件的设置。-->

## 操作：

1. ulimit -a 可以看到操作系统下的所有配置项

![1487002654](https://raw.githubusercontent.com/ZJL2019/picGo/main/img/202201141605267.png)同时我产生了java会不会产生coredump文件的这种想法。

在大多时候我们都认为java相比C/C++都更为安全，因为其完善的异常机制，不会让其毫无限制的操作内存等。

既然C/C++在解引用空指针时，会访问内存非法地址，从而导致程序崩溃。

java是否也会有相同的场景呢？

因为java本身并不支持指针，但是我猜想，所有系统级的编程语言都会操作计算机的内存。

所以其底层应该也是访问了对应的内存地址。只不过由于java安全的异常机制，不会让异常代码毫无限制的操作内存地址。

![](https://raw.githubusercontent.com/ZJL2019/picGo/main/img/202201141605268.png)

通过一个简单例子可以看出，在访问空对象时，java抛出的异常名为NullPointerException(空指针异常)证明其底层应该也用到了指针来操控内存地址。

那我们如何使用java产生coredump呢？

目前已知java的大部分程序崩溃都会被exception  catch住。

所以我们采用java调用本地方法，来实现。

```java
public class CoreDumpTest {

    //native关键字修饰的方法是对本地方法的声明，具体实现由本地方法完成
    public native void crash();

    static {
        //静态方法，载入本地动态库。load方法载入的是绝对路径下面的库
        //也可以使用loadLibrary,调用的是"java.library.path"下面的库
        //这个方法需要把生成的动态库加到目录里面，比较麻烦，我这边就直接使用绝对路径了。
        System.load("/Users/zhujiale/test/crash.so");
    }

    public static void main(String[] args) {
        new CoreDumpTest().crash();
    }
}
```

声明本地方法，并加载crash.so动态库(采用C/C++编写，解引用空指针)

------

$ javac CoreDumpTest.java

产生 CoreDumpTest.class

------

$ javah CoreDumpTest

产生 C语言的头文件 CoreDumpTest.h

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include "jni.h"
/* Header for class CoreDumpTest */

#ifndef _Included_CoreDumpTest
#define _Included_CoreDumpTest
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     CoreDumpTest
 * Method:    crash
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_CoreDumpTest_crash
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

看的出CoreDump.h中声明了Java_CoreDumpTest_crash这个方法。

接着我们通过.c源文件实现这个方法。

```c
#include "jni.h"
#include "CoreDumpTest.h"

JNIEXPORT void JNICALL Java_CoreDumpTest_crash
  (JNIEnv * env, jobject obj){
      int *p = NULL;
      *p = 3;
}
```

然后对crash.c进行编译生成.o文件

gcc -c crash.c 生成 crash.o文件

使用此命令生成crash.so动态库

gcc -shared -fPIC -o crash.so crash.o



同时我们运行CoreDumpTest java程序 其在调用本地crash方法时，依赖crash.so动态库。crash.so依赖C语言，同时对空指针解引用，程序奔溃产生CoreDump文件。

![image.jpeg](https://raw.githubusercontent.com/ZJL2019/picGo/main/img/202201141605269.png)

部分coredump文件如下图：

![image.jpeg](https://raw.githubusercontent.com/ZJL2019/picGo/main/img/202201141605270.png)

从这个实验可以得出，面对java抛出空指针的异常，其本质应该也是访问了内存地址，但是由于jvm虚拟机的存在，在检测到危险操作时，采用exception进行catch进行抛出，从而避免产生CoreDump。

由此可见java 虚拟机的机制相比于C/C++直接操作内存地址的方法，更为安全。